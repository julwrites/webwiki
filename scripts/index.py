#!/usr/bin/env python3
import os
import sys
import argparse
import json

# Determine the root directory of the repo
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
REPO_ROOT = os.getenv("TASKS_REPO_ROOT", os.path.dirname(SCRIPT_DIR))
INDEX_FILE = os.path.join(REPO_ROOT, "docs", "INDEX.yaml")

class SimpleYaml:
    """
    A simple, dependency-free YAML parser/dumper for a specific schema.
    Schema:
    key:
      subkey:
        - item
        - item
    """

    @staticmethod
    def load(filepath):
        if not os.path.exists(filepath):
            return {}

        data = {}
        current_key = None
        current_subkey = None

        with open(filepath, 'r') as f:
            for line in f:
                line_content = line.strip()
                if not line_content or line_content.startswith('#'):
                    continue

                # Check indentation
                indent = len(line) - len(line.lstrip())

                if indent == 0:
                    # Top level key (filename)
                    key = line_content.rstrip(':')
                    data[key] = {"related": [], "depends_on": []}
                    current_key = key
                    current_subkey = None
                elif indent == 2 and current_key:
                    # Subkey (related or depends_on)
                    subkey = line_content.rstrip(':')
                    if subkey in ["related", "depends_on"]:
                        current_subkey = subkey
                elif indent >= 4 and current_key and current_subkey:
                    # List item
                    if line_content.startswith('- '):
                        value = line_content[2:].strip()
                        # Remove quotes if present
                        if (value.startswith('"') and value.endswith('"')) or \
                           (value.startswith("'") and value.endswith("'")):
                            value = value[1:-1]

                        if current_subkey in data[current_key]:
                            data[current_key][current_subkey].append(value)

        return data

    @staticmethod
    def save(filepath, data):
        with open(filepath, 'w') as f:
            f.write("# Documentation Index\n")
            f.write("# Generated by scripts/index\n\n")

            # Sort keys for consistent output
            for key in sorted(data.keys()):
                f.write(f"{key}:\n")

                entry = data[key]

                # Write 'related'
                if entry.get("related"):
                    f.write("  related:\n")
                    for item in sorted(entry["related"]):
                        f.write(f"    - {item}\n")

                # Write 'depends_on'
                if entry.get("depends_on"):
                    f.write("  depends_on:\n")
                    for item in sorted(entry["depends_on"]):
                        f.write(f"    - {item}\n")

                f.write("\n")

def init_index():
    if os.path.exists(INDEX_FILE):
        print(f"Index already exists at {INDEX_FILE}")
        return

    os.makedirs(os.path.dirname(INDEX_FILE), exist_ok=True)
    SimpleYaml.save(INDEX_FILE, {})
    print(f"Initialized empty index at {INDEX_FILE}")

def validate_path(path):
    """Checks if a path exists relative to REPO_ROOT."""
    full_path = os.path.join(REPO_ROOT, path)
    return os.path.exists(full_path)

def add_entry(doc_path, related=None, depends_on=None, force=False):
    data = SimpleYaml.load(INDEX_FILE)

    if not validate_path(doc_path) and not force:
        print(f"Warning: Document path '{doc_path}' does not exist. Use --force to add anyway.")
        if not force:
            sys.exit(1)

    if doc_path not in data:
        data[doc_path] = {"related": [], "depends_on": []}

    if related:
        for r in related:
            if r not in data[doc_path]["related"]:
                data[doc_path]["related"].append(r)

    if depends_on:
        for d in depends_on:
            if d not in data[doc_path]["depends_on"]:
                data[doc_path]["depends_on"].append(d)

    SimpleYaml.save(INDEX_FILE, data)
    print(f"Updated entry for {doc_path}")

def remove_entry(doc_path, item=None, section=None):
    data = SimpleYaml.load(INDEX_FILE)

    if doc_path not in data:
        print(f"Error: {doc_path} not found in index.")
        sys.exit(1)

    if item and section:
        if section not in ["related", "depends_on"]:
            print("Error: section must be 'related' or 'depends_on'")
            sys.exit(1)

        if item in data[doc_path][section]:
            data[doc_path][section].remove(item)
            print(f"Removed '{item}' from {doc_path} ({section})")
        else:
            print(f"Item '{item}' not found in {doc_path} ({section})")

    elif not item:
        del data[doc_path]
        print(f"Removed entry for {doc_path}")

    SimpleYaml.save(INDEX_FILE, data)

def check_integrity(output_format="text"):
    data = SimpleYaml.load(INDEX_FILE)
    errors = []

    for doc_path, content in data.items():
        if not validate_path(doc_path):
            errors.append(f"Missing Document: {doc_path}")

        for r in content.get("related", []):
            if not validate_path(r):
                errors.append(f"Missing Related File: {r} (referenced by {doc_path})")

        for d in content.get("depends_on", []):
            if not validate_path(d):
                errors.append(f"Missing Dependency: {d} (referenced by {doc_path})")

    if output_format == "json":
        print(json.dumps({"valid": len(errors) == 0, "errors": errors}))
    else:
        if errors:
            print(f"Found {len(errors)} integrity errors:")
            for e in errors:
                print(f" - {e}")
            sys.exit(1)
        else:
            print("Index integrity check passed.")

def get_impact(target_file, output_format="text"):
    """
    Finds which documents are affected by a change in target_file.
    Logic:
    1. Direct Impact: Docs that list target_file in 'related'.
    2. Indirect Impact: Docs that depend on (depends_on) the Direct Impact docs.
    """
    data = SimpleYaml.load(INDEX_FILE)

    direct_impacts = set()

    # normalize target_file (remove ./ if present)
    if target_file.startswith("./"):
        target_file = target_file[2:]

    # 1. Find Direct Impacts
    for doc, content in data.items():
        # Check direct related files
        if target_file in content.get("related", []):
            direct_impacts.add(doc)

        # Check if the target is itself a dependency (if target is a doc)
        if target_file in content.get("depends_on", []):
            direct_impacts.add(doc)

    # 2. Find Transitive Impacts (Recursive)
    all_impacts = set(direct_impacts)
    queue = list(direct_impacts)
    visited = set(direct_impacts)

    while queue:
        current_doc = queue.pop(0)

        # Find docs that depend on current_doc
        for doc, content in data.items():
            if current_doc in content.get("depends_on", []):
                if doc not in visited:
                    visited.add(doc)
                    all_impacts.add(doc)
                    queue.append(doc)

    results = sorted(list(all_impacts))

    if output_format == "json":
        print(json.dumps(results))
    else:
        if not results:
            print(f"No indexed documents found that are affected by '{target_file}'.")
        else:
            print(f"Impact Analysis for '{target_file}':")
            print("-" * 50)
            for r in results:
                # Distinguish direct vs indirect?
                if r in direct_impacts:
                    print(f"[Direct]   {r}")
                else:
                    print(f"[Indirect] {r}")

def visualize(output_format="text"):
    data = SimpleYaml.load(INDEX_FILE)

    if output_format == "json":
        print(json.dumps(data))
        return

    print("graph TD")

    # We want to show:
    # Docs (Nodes)
    # Code (Nodes)
    # Edges: Doc -> Code (Related)
    # Edges: Doc -> Doc (Depends On)

    # Styling
    print("    classDef doc fill:#f9f,stroke:#333,stroke-width:2px;")
    print("    classDef code fill:#ccf,stroke:#333,stroke-width:1px;")

    nodes = set()

    for doc, content in data.items():
        doc_id = doc.replace("/", "_").replace(".", "_").replace("-", "_")
        print(f'    {doc_id}["{doc}"]:::doc')
        nodes.add(doc)

        for r in content.get("related", []):
            r_id = r.replace("/", "_").replace(".", "_").replace("-", "_")
            if r not in nodes:
                print(f'    {r_id}["{r}"]:::code')
                nodes.add(r)
            print(f"    {doc_id} -.-> {r_id}")

        for d in content.get("depends_on", []):
            d_id = d.replace("/", "_").replace(".", "_").replace("-", "_")
            if d not in nodes:
                 # It might be defined later as a key, but if not, treat as doc
                 print(f'    {d_id}["{d}"]:::doc')
                 nodes.add(d)
            print(f"    {doc_id} ==> {d_id}")

def list_entries(output_format="text"):
    data = SimpleYaml.load(INDEX_FILE)
    if output_format == "json":
        print(json.dumps(data))
    else:
        if not data:
            print("Index is empty.")
            return
        for doc in sorted(data.keys()):
            print(f"{doc}")
            content = data[doc]
            if content.get("related"):
                print("  Related Files:")
                for r in content["related"]:
                    print(f"    - {r}")
            if content.get("depends_on"):
                print("  Depends On:")
                for d in content["depends_on"]:
                    print(f"    - {d}")
            print("")

def main():
    parent_parser = argparse.ArgumentParser(add_help=False)
    parent_parser.add_argument("--format", choices=["text", "json"], default="text", help="Output format")

    parser = argparse.ArgumentParser(description="Manage Documentation Index")
    subparsers = parser.add_subparsers(dest="command")

    # Init
    subparsers.add_parser("init", help="Initialize the index file")

    # Add
    add_parser = subparsers.add_parser("add", help="Add or update an entry")
    add_parser.add_argument("doc", help="Path to the document")
    add_parser.add_argument("--related", help="Comma-separated list of related files")
    add_parser.add_argument("--depends", help="Comma-separated list of dependency documents")
    add_parser.add_argument("--force", action="store_true", help="Allow adding non-existent files")

    # Remove
    rm_parser = subparsers.add_parser("remove", help="Remove an entry or item")
    rm_parser.add_argument("doc", help="Path to the document")
    rm_parser.add_argument("--item", help="Specific item to remove")
    rm_parser.add_argument("--section", choices=["related", "depends_on"], help="Section to remove item from")

    # Impact
    impact_parser = subparsers.add_parser("impact", parents=[parent_parser], help="Check impact of a file change")
    impact_parser.add_argument("file", help="File that changed")

    # Check
    subparsers.add_parser("check", parents=[parent_parser], help="Check integrity of the index")

    # Graph
    subparsers.add_parser("graph", parents=[parent_parser], help="Generate Mermaid graph")

    # List
    subparsers.add_parser("list", parents=[parent_parser], help="List all entries")

    args = parser.parse_args()

    fmt = getattr(args, "format", "text")

    if args.command == "init":
        init_index()
    elif args.command == "add":
        related = [x.strip() for x in args.related.split(",")] if args.related else []
        depends = [x.strip() for x in args.depends.split(",")] if args.depends else []
        add_entry(args.doc, related, depends, args.force)
    elif args.command == "remove":
        remove_entry(args.doc, args.item, args.section)
    elif args.command == "impact":
        get_impact(args.file, fmt)
    elif args.command == "check":
        check_integrity(fmt)
    elif args.command == "graph":
        visualize(fmt)
    elif args.command == "list":
        list_entries(fmt)
    else:
        parser.print_help()

if __name__ == "__main__":
    main()
